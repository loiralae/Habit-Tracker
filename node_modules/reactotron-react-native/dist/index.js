'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ramda = require('ramda');
var reactNative = require('react-native');
var reactotronCoreClient = require('reactotron-core-client');

/*
 * Get React Native server IP if hostname is `localhost`
 * On Android emulator, the IP of host is `10.0.2.2` (Genymotion: 10.0.3.2)
 */
var getHost = function getHost() {
  var defaultHost = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'localhost';

  if (typeof window !== 'undefined' && window.__fbBatchedBridge && window.__fbBatchedBridge.RemoteModules && window.__fbBatchedBridge.RemoteModules.AndroidConstants) {
    var _window$__fbBatchedBr = window.__fbBatchedBridge.RemoteModules.AndroidConstants.ServerHost,
        ServerHost = _window$__fbBatchedBr === undefined ? defaultHost : _window$__fbBatchedBr;

    return ServerHost.split(':')[0];
  }

  return defaultHost;
};

/**
 * Provides a global error handler to report errors..
 */
// a few functions to help source map errors -- these seem to be not available immediately
// so we're lazy loading.
var parseErrorStack = void 0;
var symbolicateStackTrace = void 0;

// defaults
var PLUGIN_DEFAULTS = {
  veto: null // frame -> boolean
};

// const reactNativeFrameFinder = frame => contains('/node_modules/react-native/', frame.fileName)

// our plugin entry point
var trackGlobalErrors = (function (options) {
  return function (reactotron) {
    // setup configuration
    var config = ramda.merge(PLUGIN_DEFAULTS, options || {});

    var swizzled = null;
    var isSwizzled = false;

    function reactotronExceptionHijacker(message, prettyStack, currentExceptionID) {
      // do Facebook's stuff first
      swizzled(message, prettyStack, currentExceptionID);

      // then convert & transport it
      try {
        // rewrite the stack frames to be in the format we're expecting
        var stack = ramda.map(function (frame) {
          return {
            functionName: frame.methodName === '<unknown>' ? null : frame.methodName,
            lineNumber: frame.lineNumber,
            columnNumber: frame.column,
            fileName: frame.file
          };
        }, prettyStack);

        // does the dev want us to keep each frame?
        if (config.veto) {
          stack = ramda.reject(config.veto, stack);
        }

        // throw it over to us
        reactotron.error(message, stack);
      } catch (e) {
        // TODO: no one must ever know our dark secrets
      }
    }

    // here's how to swizzle
    function trackGlobalErrors() {
      if (isSwizzled) return;
      swizzled = reactNative.NativeModules.ExceptionsManager.updateExceptionMessage;
      reactNative.NativeModules.ExceptionsManager.updateExceptionMessage = reactotronExceptionHijacker;
      isSwizzled = true;
    }

    // restore the original
    function untrackGlobalErrors() {
      if (!swizzled) return;
      reactNative.NativeModules.ExceptionsManager.updateExceptionMessage = swizzled;
      isSwizzled = false;
    }

    // auto start this
    trackGlobalErrors();

    // manually fire an error
    function reportError(error) {
      try {
        parseErrorStack = parseErrorStack || require('react-native/Libraries/Core/Devtools/parseErrorStack');
        symbolicateStackTrace = symbolicateStackTrace || require('react-native/Libraries/Core/Devtools/symbolicateStackTrace');
        if (parseErrorStack && symbolicateStackTrace) {
          var parsedStacktrace = parseErrorStack(error);

          symbolicateStackTrace(parsedStacktrace).then(function (goodStack) {
            var stack = goodStack.map(function (stackFrame) {
              return {
                fileName: stackFrame.file,
                functionName: stackFrame.methodName,
                lineNumber: stackFrame.lineNumber
              };
            });

            // does the dev want us to keep each frame?
            if (config.veto) {
              stack = ramda.reject(config.veto, stack);
            }

            reactotron.error(error.message, stack);
          });

          return;
        }
      } catch (e) {
        // nothing happened. move along.
      }
    }

    // the reactotron plugin interface
    return {
      // attach these functions to the Reactotron
      features: {
        reportError: reportError,
        trackGlobalErrors: trackGlobalErrors,
        untrackGlobalErrors: untrackGlobalErrors
      }
    };
  };
});

var DEFAULTS$1 = {
  url: 'http://localhost:8081'
};

var openInEditor = (function () {
  var pluginConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (reactotron) {
    var options = ramda.merge(DEFAULTS$1, pluginConfig);

    return {
      onCommand: function onCommand(command) {
        if (command.type !== 'editor.open') return;
        var payload = command.payload;
        var file = payload.file,
            lineNumber = payload.lineNumber;

        var url = options.url + '/open-stack-frame';
        var body = { file: file, lineNumber: lineNumber || 1 };
        var method = 'POST';

        fetch(url, { method: method, body: JSON.stringify(body) });
      }
    };
  };
});

// -----------
// FIRST PARTY
// -----------

// import validate from './validate'
// ------------
// SECOND PARTY
// ------------

// -----------
// THIRD PARTY
// -----------

var io = require('socket.io-client/dist/socket.io');

// ---------------------
// DEFAULT CONFIGURATION
// ---------------------

var DEFAULTS = {
  io: io,
  host: getHost('localhost'),
  port: 9090,
  name: 'React Native App',
  userAgent: 'reactotron-react-native',
  reactotronVersion: 'BETA', // TODO: figure this out for realz.  why is this hard?  it must be me.
  environment: __DEV__ ? 'development' : 'production' // naive... TODO: find the right way ya lazy bum.
};

// -----------
// HERE WE GO!
// -----------
// Create the default reactotron.
var reactotron = reactotronCoreClient.createClient(DEFAULTS);

exports.trackGlobalErrors = trackGlobalErrors;
exports.openInEditor = openInEditor;
exports['default'] = reactotron;
