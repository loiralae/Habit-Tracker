'use strict';

var reduxSaga_utils = require('redux-saga/utils');
var ramdasauce = require('ramdasauce');
var ramda = require('ramda');

// effect names
var TAKE = 'TAKE';
var PUT = 'PUT';
var CALL = 'CALL';
var CPS = 'CPS';
var FORK = 'FORK';
var JOIN = 'JOIN';
var RACE = 'RACE';
var CANCEL = 'CANCEL';
var SELECT = 'SELECT';
var PARALLEL = 'PARALLEL';
var ITERATOR = 'ITERATOR';
var UNKNOWN = 'UNKNOWN'; // not from redux-saga

// monitoring statuses
var PENDING = 'PENDING';
var RESOLVED = 'RESOLVED';
var REJECTED = 'REJECTED';
var CANCELLED = 'CANCELLED';

var getEffectName = (function (effect) {
  if (reduxSaga_utils.asEffect.take(effect)) return TAKE;
  if (reduxSaga_utils.asEffect.put(effect)) return PUT;
  if (reduxSaga_utils.asEffect.call(effect)) return CALL;
  if (reduxSaga_utils.asEffect.cps(effect)) return CPS;
  if (reduxSaga_utils.asEffect.fork(effect)) return FORK;
  if (reduxSaga_utils.asEffect.join(effect)) return JOIN;
  if (reduxSaga_utils.asEffect.race(effect)) return RACE;
  if (reduxSaga_utils.asEffect.cancel(effect)) return CANCEL;
  if (reduxSaga_utils.asEffect.select(effect)) return SELECT;
  if (reduxSaga_utils.is.array(effect)) return PARALLEL;
  if (reduxSaga_utils.is.iterator(effect)) return ITERATOR;
  return UNKNOWN;
});

// Provides an additional description of the effect.  A friendlier name
// to display to the humans.
/* eslint-disable no-cond-assign */
var getEffectDescription = (function (effect) {
  if (effect.root) return effect.saga.name;
  var data = void 0;
  if (data = reduxSaga_utils.asEffect.take(effect)) return data.pattern || 'channel';
  if (data = reduxSaga_utils.asEffect.put(effect)) return data.channel ? data.action : data.action.type;
  if (data = reduxSaga_utils.asEffect.call(effect)) return ramdasauce.isNilOrEmpty(data.fn.name) ? '(anonymous)' : data.fn.name;
  if (data = reduxSaga_utils.asEffect.cps(effect)) return data.fn.name;
  if (data = reduxSaga_utils.asEffect.fork(effect)) return data.fn.name;
  if (data = reduxSaga_utils.asEffect.join(effect)) return data.name;
  if (reduxSaga_utils.asEffect.race(effect)) return null;
  if (data = reduxSaga_utils.asEffect.cancel(effect)) return data.name;
  if (data = reduxSaga_utils.asEffect.select(effect)) return data.selector.name;
  if (reduxSaga_utils.is.array(effect)) return null;
  if (reduxSaga_utils.is.iterator(effect)) return effect.name;
  return UNKNOWN;
});

// creates a saga monitor
var _createSagaMonitor = (function (reactotron, options) {
  // a lookup table of effects - keys are numbers, values are objects
  var effects = {};

  // filtering that effect table
  var byParentId = ramda.propEq('parentEffectId', ramda.__);
  var byLabel = ramda.propEq('label', ramda.__);
  var getChildEffectInfos = function getChildEffectInfos(parentEffectId) {
    return ramda.filter(byParentId(parentEffectId), ramda.values(effects));
  };
  var getChildEffectIds = function getChildEffectIds(effectId) {
    return ramda.pluck('effectId', getChildEffectInfos(effectId));
  };

  // start a relative timer
  var timer = reactotron.startTimer();

  // ---------------- Starting -----------------------------

  // redux-saga calls this when an effect is triggered (started)
  var effectTriggered = function effectTriggered(description) {
    var effect = description.effect,
        effectId = description.effectId,
        parentEffectId = description.parentEffectId,
        label = description.label;

    // create an EffectInfo to hold the details

    var effectInfo = {
      effectId: effectId,
      parentEffectId: parentEffectId,
      effect: effect,
      label: label,
      status: PENDING,
      name: getEffectName(effect),
      description: getEffectDescription(effect),
      result: null,
      startedAt: timer()
    };

    // store it
    effects[effectId] = effectInfo;
  };

  // ---------------- Finishing ----------------------------

  // update the duration of the effect
  var updateDuration = function updateDuration(effectInfo) {
    effectInfo.duration = timer() - effectInfo.startedAt;
  };

  // fires when a task has been resolved
  var taskResolved = function taskResolved(effectId, taskResult) {
    // lookup this effect info
    var effectInfo = effects[effectId];
    updateDuration(effectInfo);
    var duration = effectInfo.duration;

    // grab the parent too

    var parentEffectId = effectInfo.parentEffectId;

    var parentEffectInfo = effects[parentEffectId];
    var children = [];

    // a human friendly name of the saga task
    var sagaDescription = void 0;
    // what caused the trigger
    var triggerType = void 0;

    // for FORK tasks, we have a bunch on things to pass along
    if (effectInfo.name === FORK) {
      (function () {
        var args = ramda.pathOr([], ramda.split('.', 'effect.FORK.args'), effectInfo);
        var lastArg = ramda.last(args);
        triggerType = lastArg && lastArg.type;
        if (parentEffectInfo) {
          if (parentEffectInfo.name === ITERATOR) {
            sagaDescription = parentEffectInfo.description;
          }
        } else {
          sagaDescription = '(root)';
          triggerType = effectInfo.description + '()';
        }

        // flatten out the nested effects
        var buildChild = function buildChild(depth, effectId) {
          var sourceEffectInfo = effects[effectId];
          if (ramda.isNil(sourceEffectInfo)) return;

          var extra = null;
          switch (sourceEffectInfo.name) {
            case CALL:
              extra = sourceEffectInfo.effect[sourceEffectInfo.name].args;
              break;

            case PUT:
              extra = sourceEffectInfo.effect[sourceEffectInfo.name].action;
              break;

            // children handle this
            case RACE:
              break;

            // TODO: More of customizations needed here

            default:
              extra = sourceEffectInfo.effect[sourceEffectInfo.name];
              break;
          }
          // assemble the structure
          children.push({
            depth: depth,
            effectId: sourceEffectInfo.effectId,
            parentEffectId: sourceEffectInfo.parentEffectId,
            name: sourceEffectInfo.name,
            description: sourceEffectInfo.description,
            duration: Math.round(sourceEffectInfo.duration),
            status: sourceEffectInfo.status,
            winner: sourceEffectInfo.winner,
            loser: sourceEffectInfo.loser,
            result: sourceEffectInfo.result,
            extra: extra
          });

          // rerun this function for our children
          ramda.forEach(function (x) {
            return buildChild(depth + 1, x);
          }, getChildEffectIds(effectId));
        };
        var xs = getChildEffectIds(effectId);
        ramda.forEach(function (effectId) {
          return buildChild(0, effectId);
        }, xs);
      })();
    }

    reactotron.send('saga.task.complete', {
      triggerType: triggerType || effectInfo.description,
      description: sagaDescription,
      duration: Math.round(duration),
      children: children
    });
  };

  // redux-saga calls this when an effect is resolved (successfully or not)
  var effectResolved = function effectResolved(effectId, result) {
    // lookup this effect info and set the rsult
    var effectInfo = effects[effectId];
    updateDuration(effectInfo);
    effectInfo.result = result;

    // this is a task
    if (reduxSaga_utils.is.task(result)) {
      // when the task promise resolves,
      var onTaskResult = function onTaskResult(taskResult) {
        if (result.isCancelled()) {
          effectCancelled(effectId);
        } else {
          effectResolved(effectId, taskResult);
          taskResolved(effectId, taskResult);
        }
      };

      // hook the promise to capture the resolve or reject
      result.done.then(onTaskResult, function (error) {
        effectRejected(effectId, error);
        if (!error.reactotronWasHere) {
          reactotron.reportError(error);
        }
        error.reactotronWasHere = true;
      });
    } else {
      // this is an effect and we are complete
      effectInfo.status = RESOLVED;
      effectInfo.result = result;
      if (effectInfo.name === RACE) {
        setRaceWinner(effectId, result);
      }
    }
  };

  // flags on of the children as the winner
  var setRaceWinner = function setRaceWinner(effectId, resultOrError) {
    var winnerLabel = Object.keys(resultOrError)[0];
    var children = getChildEffectInfos(effectId);
    var winningChildren = ramda.filter(byLabel(winnerLabel), children);
    var losingChildren = ramda.reject(byLabel(winnerLabel), children);
    var setWinner = function setWinner(effectInfo) {
      effectInfo.winner = true;
    };
    var setLoser = function setLoser(effectInfo) {
      effectInfo.loser = true;
    };

    // set the 1 (hopefully 1) winner -- but i'm not sure
    ramda.forEach(setWinner, winningChildren);
    ramda.forEach(setLoser, losingChildren);
  };

  // ---------------- Failing ------------------------------

  // redux-saga calls this when an effect is rejected (an error has happened)
  var effectRejected = function effectRejected(effectId, error) {
    var effectInfo = effects[effectId];
    updateDuration(effectInfo);
    effectInfo.status = REJECTED;
    effectInfo.error = error;
    if (effectInfo.name === RACE) {
      setRaceWinner(effectId, error);
    }
  };

  // ---------------- Cancelling ---------------------------

  // redux-saga calls this when an effect is cancelled
  var effectCancelled = function effectCancelled(effectId) {
    var effectInfo = effects[effectId];
    updateDuration(effectInfo);
    effectInfo.status = CANCELLED;
  };

  // the interface for becoming a redux-saga monitor
  return {
    effectTriggered: effectTriggered,
    effectResolved: effectResolved,
    effectRejected: effectRejected,
    effectCancelled: effectCancelled,
    actionDispatched: function actionDispatched() {}
  };
});

// Behold!  The entry point of our plugin
var plugin$1 = (function (pluginConfig) {
  return function (reactotron) {
    return {
      // make these functions available on the Reactotron
      features: {
        // spawn a saga monitor with the given options
        createSagaMonitor: function createSagaMonitor(options) {
          return _createSagaMonitor(reactotron, options);
        }
      }
    };
  };
});

module.exports = plugin$1;
